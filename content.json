{"meta":{"title":"烟风雨沫","subtitle":null,"description":null,"author":null,"url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-06-30T00:36:11.000Z","updated":"2019-06-30T00:38:51.091Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-01-15T22:17:29.000Z","updated":"2019-06-30T00:34:00.954Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"装饰器设计模式","slug":"装饰器设计模式（Java）","date":"2020-05-06T03:03:00.000Z","updated":"2020-05-06T03:14:29.077Z","comments":true,"path":"2020/05/06/装饰器设计模式（Java）/","link":"","permalink":"http://yoursite.com/2020/05/06/装饰器设计模式（Java）/","excerpt":"","text":"装饰器设计模式（Java）一、组成示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Decorate&#123;&#125;/*抽象组件*/interface Drink&#123; double cost(); String info();&#125;/*具体组件*/class Coffee implements Drink&#123; private String name = \"原味咖啡\"; private double price = 10.0; @Override public double cost() &#123; return price; &#125; @Override public String info() &#123; return name; &#125;&#125;/*抽象装饰类*/class DecorateClass implements Drink&#123; private Drink drink; public DecorateClass(Drink drink)&#123; this.drink = drink; &#125; @Override public double cost() &#123; return this.drink.cost(); &#125; @Override public String info() &#123; return this.drink.info(); &#125;&#125;/*具体装饰类*/class Milk extends DecorateClass&#123; public Milk(Drink drink) &#123; super(drink); &#125; @Override public double cost() &#123; return super.cost()*4; &#125; @Override public String info() &#123; return super.info() + \"加奶！！\"; &#125;&#125; 二、Java内使用 以I/O流为例 InputStream; -&gt; 抽象组件ByteArrayInputStream; -&gt; 具体组件FileInputStream; -&gt; 具体组件FilterInputStream; -&gt; 抽象装饰类BufferedInputStream; -&gt; 具体装饰类","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"test","slug":"test","date":"2020-04-25T12:49:50.000Z","updated":"2020-04-25T12:51:49.562Z","comments":true,"path":"2020/04/25/test/","link":"","permalink":"http://yoursite.com/2020/04/25/test/","excerpt":"","text":"","categories":[],"tags":[{"name":"测试gitBash on windows platform","slug":"测试gitBash-on-windows-platform","permalink":"http://yoursite.com/tags/测试gitBash-on-windows-platform/"}]},{"title":"长难句之一 简单句","slug":"长难句 之 简单句","date":"2020-04-25T11:29:30.000Z","updated":"2020-05-06T03:06:26.901Z","comments":true,"path":"2020/04/25/长难句 之 简单句/","link":"","permalink":"http://yoursite.com/2020/04/25/长难句 之 简单句/","excerpt":"","text":"[TOC] 长难句 之 简单句 一、五种基本结构 主谓 主谓宾 主谓表 此处的谓语动词，特指系动词。 区分与主谓宾的差别主要看谓语动词是系动词，还是实义动词。 系动词分类 表示状态： be动词（链接主语和表语，无实意） 表示感官：look, sound, taste, smell, feel(感官动词后只能跟形容词) 表示变化：get, become, turn, grow, fall 表示保持：keep, stay, remain, stand 表示表象： seem, appear 表示终止：prove 主谓双宾 常用谓语动词：buy, pass, lend, give, tell, teach, show, bring, send等。 主谓宾宾补 宾补用于补充说明宾语的特点、身份，或让宾语完成某个动作。 区分双宾和宾补方法：在两个成分中间加个系动词，看前后成分构成的结构是否通顺。 ask sb to do sth want sb to do sth make sb sth make sb do sth 二、句子成分 谓语动词或者动词词组做谓语[^系动词或实意动词，非情态动词] == 谓语就是具有时态的实义动词（或词组）或者系动词== 谓语只能是动词，动词只能充当谓语。 句子中不作谓语的动词成分 —— 需要变成非谓语动词结构 动词后跟 -ing[^ 动词的现在分词]，表示主动或进行。 动词后跟 -ed[^ 动词的过去分词]，表示被动或完成。 动词后加 to[^ 动词不定式]，表示目的或将来。 __ 非谓语结构可以充当除谓语外的所有成分 __ 谓语必须是实义动词或系动词，并且必须有时态和语态。一句话中动词有且只能有一个，多余的变成非谓语结构，少了的就加be动词。 主语主语成分：名词、代词、非谓语结构 主语能否缺失： it作主语（描述天气），或者形式主语。 There Be 句型，表示存在，并且主语比较模糊。 变主动为被动。 123456think -&gt; argue,contend,assume, presume, insist, maintain, assert, claim, be of the option that, have been convinced that, cling to the perspective that important -&gt; be of great importance, vital, significant, essential, indispensable, play a key role in sth 加人称代词（万不得已） 宾语能做宾语的成分和主语完全一样。 表语表语成分：代词、名词（短语）、非谓语结构、形容词（短语）和介词短语。 三、动词的时态（略）四、动词的分类 实义动词：表示具体动作，分为及物和不及物 系动词，见本章第一节 情态动词：表示说话人的主观态度不能单独出现，必须和实义动词/系动词一起构成谓语。 can/could -&gt; be capable of, be competent in may/might -&gt; be likely to must/have to -&gt; be bound to, be bound for should/ought -&gt; be supposed to, be obliged to would -&gt; intend to need dare 情态动词的完成时表示推测 must have done：一定做过某事 needn’t have done：本没必要做某事，但是已经做了 couldn’t have done：本能够做某事，但是没有做，表示遗憾 should have done：本应该做某事","categories":[],"tags":[{"name":"考研英语长难句","slug":"考研英语长难句","permalink":"http://yoursite.com/tags/考研英语长难句/"}]},{"title":"浙大版数据结构网址","slug":"浙大版数据结构网址","date":"2019-07-03T02:02:46.000Z","updated":"2019-07-03T02:03:48.606Z","comments":true,"path":"2019/07/03/浙大版数据结构网址/","link":"","permalink":"http://yoursite.com/2019/07/03/浙大版数据结构网址/","excerpt":"","text":"浙大版数据结构笔记","categories":[],"tags":[]},{"title":"广义表","slug":"广义表","date":"2019-07-03T01:19:36.000Z","updated":"2019-07-03T01:31:55.421Z","comments":true,"path":"2019/07/03/广义表/","link":"","permalink":"http://yoursite.com/2019/07/03/广义表/","excerpt":"","text":"广义表的概念和定义概念 广义表是线性表的推广 对于线性表而言，n个元素都是基本的单元素 广义表中，这些元素不仅可以是单元素，也可以是另一个广义表 代码定义123456789typedef struct GNode *GList;struct GNode&#123; int Tag; /*标志域：0表示节点是单元素，1表示节点是广义表*/ union&#123; /*子表指针域Sublist与单元素数据域Data复用，公用存储空间*/ ElementType Data; GList SubList &#125;URegion GList Next; /*指向后继节点*/&#125;;","categories":[],"tags":[]},{"title":"最小子列和代码实现","slug":"最小子列和代码实现","date":"2019-07-03T00:38:55.000Z","updated":"2019-07-03T00:49:57.178Z","comments":true,"path":"2019/07/03/最小子列和代码实现/","link":"","permalink":"http://yoursite.com/2019/07/03/最小子列和代码实现/","excerpt":"","text":"最小子列和代码实现C语言实现123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXNUM ...int onlineCope(int *sequece, int size)&#123; int i; int thisSum = 0; int maxSum = 0; for(i = 0; i &lt; n; i++)&#123; thisSum += sequece[i]; if(thisSum &gt; maxSum)&#123; maxSum = thisSum; &#125; else if(thisSum &lt; 0)&#123; thisSum = 0; &#125; &#125;&#125;int main()&#123; int sequece[MAXNUM] = &#123;&#125;; // int size = sizeof(sequece)/sizeof(int);&#125;","categories":[],"tags":[]},{"title":"广度优先遍历原理及其实现","slug":"广度优先遍历原理及其实现","date":"2019-07-02T14:39:48.000Z","updated":"2019-07-02T14:51:58.185Z","comments":true,"path":"2019/07/02/广度优先遍历原理及其实现/","link":"","permalink":"http://yoursite.com/2019/07/02/广度优先遍历原理及其实现/","excerpt":"","text":"FS 实现原理及python代码原理​ BFS核心原理是使用队列对图的顶点进行遍历操作。 step1​ 建立Seen[] 数组，将已经访问的节点存入该集合。 ​ 开始节点入队q，并存入Seen数组。 step2​ 开始循环判断队列是否为空。若不空，则出对头元素，将该元素所有的邻接点（判断是否在seen中后）入队，并对应节点存入seen中，输出此轮弹出的节点。 python代码实现12345678910111213141516171819202122232425graph =&#123; \"A\" : [\"B\", \"C\"], \"B\" : [\"A\", \"C\", \"D\"], \"C\" : [\"A\", \"B\", \"D\", \"E\"], \"D\" : [\"B\", \"C\", \"E\", \"F\"], \"E\" : [\"C\", \"D\"], \"F\" : [\"D\"] &#125;def BFS(graph, vertexStr): queue = [] queue.append(vertexStr) seen = set() #存放已经访问过的点 seen.add(vertexStr) while(len(queue) &gt; 0): vertex = queue.pop(0) nodes = graph[vertex] for w in nodes: if w not in seen: queue.append(w) seen.add(w) print(vertex)BFS(graph, \"A\")","categories":[],"tags":[]},{"title":"深度优先遍历原理及其实现","slug":"深度优先遍历原理及其实现","date":"2019-07-02T14:27:49.000Z","updated":"2019-07-02T14:44:46.772Z","comments":true,"path":"2019/07/02/深度优先遍历原理及其实现/","link":"","permalink":"http://yoursite.com/2019/07/02/深度优先遍历原理及其实现/","excerpt":"","text":"DFS 实现原理及python代码原理​ DFS核心原理是使用栈对图的顶点进行遍历操作。 step1​ 建立Seen[] 数组，将已经访问的节点存入该集合。 ​ 开始节点入栈S，并存入Seen数组。 step2​ 开始循环判断栈是否为空。若不空，则弹出栈顶元素，将该元素所有的邻接点（判断是否在seen中后）压入栈中，并对应节点存入seen中，输出此轮弹出的节点。 python代码实现12345678910111213141516171819202122232425graph =&#123; \"A\" : [\"B\", \"C\"], \"B\" : [\"A\", \"C\", \"D\"], \"C\" : [\"A\", \"B\", \"D\", \"E\"], \"D\" : [\"B\", \"C\", \"E\", \"F\"], \"E\" : [\"C\", \"D\"], \"F\" : [\"D\"] &#125;def DFS(graph, vertexStr): stack = [] stack.append(vertexStr) seen = set() #存放已经访问过的点 seen.add(vertexStr) while(len(stack) &gt; 0): vertex = stack.pop() nodes = graph[vertex] for w in nodes: if w not in seen: stack.append(w) seen.add(w) print(vertex)DFS(graph, \"A\")","categories":[],"tags":[]},{"title":"Floyd 代码实现","slug":"Floyd-代码实现","date":"2019-07-02T14:13:38.000Z","updated":"2019-07-02T14:16:03.163Z","comments":true,"path":"2019/07/02/Floyd-代码实现/","link":"","permalink":"http://yoursite.com/2019/07/02/Floyd-代码实现/","excerpt":"","text":"Floyd 代码实现1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N ../* D 和 Path， D记录最短路径长度，初始化为邻接矩阵 ，path记录两顶点间最短路径上经过的中间顶点*/void floyd(graph G, int Path[][])&#123; for(i = 0; i &lt; N; i++)&#123; for( j = 0; j &lt; N; j++)&#123; D[i][j] = G[i][j]; Path[i][j] = -1; &#125; &#125; for(k = 0; k &lt; N; k++)&#123; //第k轮，将k节点插入i，j中间更新最短路 长度 for(i = 0; i &lt; N; i++)&#123; for(j = 0; j &lt; N; j++)&#123; if(D[i][k] + D[k][j] &lt; D[i][j])&#123; //主要判断条件 D[i][j] = D[i][k] + D[k][j]; Path[i][j] = k; &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"dijkstra","slug":"dijkstra","date":"2019-07-02T11:39:58.000Z","updated":"2019-07-02T13:14:33.650Z","comments":true,"path":"2019/07/02/dijkstra/","link":"","permalink":"http://yoursite.com/2019/07/02/dijkstra/","excerpt":"","text":"dijkstra算法的一般原理及实现​ 初始变量：VertexsNum //顶点个数 ​ Arc[VertexsNum] [VertexsNum] //图的存储结构 ​ S[VertexsNum] = {0}; //已考察顶点的标记，初始为0；若已考察，置1 ​ dist[VertexsNum] //到该顶点当前的最小距离,dist[] 的初始值dist[i] = arcs[0][i]； ​ path[VertexsNum] //表示到该顶点当前最短路径的前驱节点 1. 原理step 1:​ 将源点的S[]数组对应位置置1，dist[] 的初始值dist[i] = arcs[0][i]； step2:​ 从顶点集合V-S中选出Vj，该Vj满足dist[j] = Min{dist [i] | Vi ∈ V-S} ，将Vj并入S； step3：​ 修改从V0出发到集合V-S上其他顶点Vk可达的最短路径长度：如果dist[j] + arcs[j][k] &lt; dist[k]，则令dist[k] = dist[j] + arcs[j][k]； step4：​ 重复 2~3，共操作n - 1次，直到所有顶点都包含在S中。 c代码伪码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;math.h&gt;#define VERTEXS 5void find_Min()&#123; //对当前未检查序列权值进行排序&#125;void dijsktra(int *arc, int *dist, int *S, int *path)&#123; int i, k; //循环变量 for(i = 0; i &lt; VERTEXS - 1; i++)&#123; sort(dist); //sort dist=&gt;V-S int j = find_Min(); s[j] = 1; //将顶点j并入已检查序列中 for(k = 0; k &lt; VERTEXS - 1;k++)&#123; if(dist[j] + arcs[j][k] &lt; dist[k])&#123; dist[k] = dist[j] + arcs[j][k]; path[k] = j; &#125; &#125; &#125;&#125;int main()&#123; int arc[VERTEXS][VERTEXS] = &#123; &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;,... &#125;; int dist[VERTEXS] = &#123;&#125;; //到该顶点当前的最小距离,dist[] 的初始值dist[i] = arcs\\[0][i]； int path[VERTEXS] = &#123;&#125;; //当前最短路径的前驱 int S[VERTEXS] = &#123;0&#125;; return 0;&#125;","categories":[],"tags":[]},{"title":"typora简易手册","slug":"typora简易手册","date":"2019-07-01T14:58:05.000Z","updated":"2019-07-01T15:44:35.128Z","comments":true,"path":"2019/07/01/typora简易手册/","link":"","permalink":"http://yoursite.com/2019/07/01/typora简易手册/","excerpt":"","text":"区域元素1.分割线​ 输入 *** / —，换行键换行 1--- 2.段落​ 按换行键 3.标题​ 开头#的个数（谨记加上文字之间空格），标题有1~6个级别，#表示开始，按换行键结束 123# H1## H2###### H6 4.引注​ 开头 “&gt;” + 空格 + 文字 ，按换行键换行，双按换行跳出 1234&gt; wang&gt; zhe&gt; rong&gt; yao wangzherongyao 5.序列​ 开头 “ * / + / - ” + 空格 + 文字，可以创建无序序列，换行键换行，删除键+shift+tab跳出 123* wang+ zhe- rong wang zhe rong ​ 开头 “ 1. ” + 空格 + 文字，可以创建有序序列 121. wang2. zhe wang zhe 6.可选序列(创建选项)​ 开头 “ * / + / - ” + 空格 + [ ] + 空格 + 文字，换行键换行，删除键+shift+tab跳出 1234- [ ] a+ [ ] b* [ ] c- [x] completed a b c completed 7.代码块​ 开头 “ + 语言名，开启代码块，换行键换行，光标下移键跳出123```markdown​```markdown 1(like this) 8.数学块​ 开头 ” $$ “ + 换行键，产生输入区域，输入Tex/LaTex格式的数学公式 1$$ $$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\end{vmatrix}$$ 9.表格开头 “ | ” + 列名 + “ | ” + 列名 + “ | ” + 换行键，创建一个2*2表格 将鼠标放置其上，弹出编辑尺寸，个数，文字等 1| 1 | 2 | 1 2 10.脚注在需要添加脚注的文字后面 + [ + ^ + 序列 + ]，注释的产生可以鼠标放置其上单击自动产生，添加信息 或人工添加 + [ + ^ + 序列 + ] + : 12脚注产生的方法[^footnote].[^footnote]:这个就是*脚注* 脚注产生的方法^footnote. 特征元素1.链接","categories":[],"tags":[{"name":"typora建议手册，时时看","slug":"typora建议手册，时时看","permalink":"http://yoursite.com/tags/typora建议手册，时时看/"}]},{"title":"并查集（after watching the video of dengshen）","slug":"并查集（after-watching-the-video-of-dengshen）","date":"2019-07-01T14:53:58.000Z","updated":"2019-07-02T15:05:47.477Z","comments":true,"path":"2019/07/01/并查集（after-watching-the-video-of-dengshen）/","link":"","permalink":"http://yoursite.com/2019/07/01/并查集（after-watching-the-video-of-dengshen）/","excerpt":"","text":"并查集视频观后有感原理​ 采用双亲法存放图，核心数据结构是一个数组parents[vertexNum]，存放各个并查集中节点的双亲节点位置，若为根节点，则置为-1（初始均为-1，加入边时，需要合理规定谁为父节点）。 ​ 建立寻根函数find_root，当压入边时，需要检查边的两个节点所在并查集的根节点是否一样，若一样，则位于同一并查集中，证明该图中存在环。否则当判断节点均位于同一并查集时，则图中不存在环。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define VERTICES 6/* initialize array of vertex parent and array of vertex rank*/void initialize(int parents[], int rank[])&#123; int i; for(i = 0; i &lt; VERTICES; i++)&#123; parents[i] = -1; rank[i] = 0; &#125;&#125;/*find root of vertex of arc to verdict*/int find_x_root(int parents[], int x)&#123; int x_root = x; while(parents[x_root] != -1)&#123; x_root = parents[x_root]; &#125; return x_root;&#125;/* union vertex set, 1 success 0 failed*/int union_vertexSet(int x, int y, int parent[], int rank[])&#123; int x_root = find_x_root(parent, x); int y_root = find_x_root(parent, y); if( x_root != y_root)&#123; if(rank[y_root] &gt; rank[x_root])&#123; parent[x_root] = y_root; &#125;else if(rank[y_root] &lt; rank[x_root])&#123; parent[y_root] = x_root; &#125;else&#123; parent[x_root] = y_root; rank[y_root]++; &#125; return 1; &#125;else&#123; return 0; &#125;&#125;int main(void)&#123; int parents[VERTICES] = &#123;0&#125;; int rank[VERTICES] = &#123;0&#125;; int edges[6][2]=&#123; &#123;0, 1&#125;, &#123;1, 2&#125;, &#123;1, 3&#125;, &#123;2, 4&#125;,&#123;3, 4&#125;, &#123;2, 5&#125;, &#125;; initialize(parents, rank); int i; for(i = 0; i &lt; 5; i++)&#123; int x = edges[i][0]; int y = edges[i][1]; if(union_vertexSet(x, y, parents, rank) == 0)&#123; printf(\"Cycle detected!\\n\"); exit(0); &#125; &#125; printf(\"No cycles found.\\n\"); return 0;&#125;","categories":[],"tags":[]},{"title":"my review of Mr.s yang","slug":"my-review-of-Mr-s-yang","date":"2019-06-30T11:29:30.000Z","updated":"2020-04-25T10:28:39.057Z","comments":true,"path":"2019/06/30/my-review-of-Mr-s-yang/","link":"","permalink":"http://yoursite.com/2019/06/30/my-review-of-Mr-s-yang/","excerpt":"","text":"这是一个人对于另外一个人的主观评价PART 01​ 半年的室友 PART 02​ 待人真诚的朋友 PART 03​ 希望成为永远的兄弟（我兄他弟） PART04​ 太过腼腆，自己活得很累","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-06-29T22:50:25.441Z","updated":"2019-06-29T22:50:25.441Z","comments":true,"path":"2019/06/30/hello-world/","link":"","permalink":"http://yoursite.com/2019/06/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}