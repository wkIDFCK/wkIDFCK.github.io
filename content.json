{"meta":{"title":"烟风雨沫","subtitle":null,"description":null,"author":null,"url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-06-30T00:36:11.000Z","updated":"2019-06-30T00:38:51.091Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-01-15T22:17:29.000Z","updated":"2019-06-30T00:34:00.954Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"最小子列和代码实现","slug":"最小子列和代码实现","date":"2019-07-03T00:38:55.000Z","updated":"2019-07-03T00:49:57.178Z","comments":true,"path":"2019/07/03/最小子列和代码实现/","link":"","permalink":"http://yoursite.com/2019/07/03/最小子列和代码实现/","excerpt":"","text":"最小子列和代码实现C语言实现123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXNUM ...int onlineCope(int *sequece, int size)&#123; int i; int thisSum = 0; int maxSum = 0; for(i = 0; i &lt; n; i++)&#123; thisSum += sequece[i]; if(thisSum &gt; maxSum)&#123; maxSum = thisSum; &#125; else if(thisSum &lt; 0)&#123; thisSum = 0; &#125; &#125;&#125;int main()&#123; int sequece[MAXNUM] = &#123;&#125;; // int size = sizeof(sequece)/sizeof(int);&#125;","categories":[],"tags":[]},{"title":"广度优先遍历原理及其实现","slug":"广度优先遍历原理及其实现","date":"2019-07-02T14:39:48.000Z","updated":"2019-07-02T14:51:58.185Z","comments":true,"path":"2019/07/02/广度优先遍历原理及其实现/","link":"","permalink":"http://yoursite.com/2019/07/02/广度优先遍历原理及其实现/","excerpt":"","text":"FS 实现原理及python代码原理​ BFS核心原理是使用队列对图的顶点进行遍历操作。 step1​ 建立Seen[] 数组，将已经访问的节点存入该集合。 ​ 开始节点入队q，并存入Seen数组。 step2​ 开始循环判断队列是否为空。若不空，则出对头元素，将该元素所有的邻接点（判断是否在seen中后）入队，并对应节点存入seen中，输出此轮弹出的节点。 python代码实现12345678910111213141516171819202122232425graph =&#123; \"A\" : [\"B\", \"C\"], \"B\" : [\"A\", \"C\", \"D\"], \"C\" : [\"A\", \"B\", \"D\", \"E\"], \"D\" : [\"B\", \"C\", \"E\", \"F\"], \"E\" : [\"C\", \"D\"], \"F\" : [\"D\"] &#125;def BFS(graph, vertexStr): queue = [] queue.append(vertexStr) seen = set() #存放已经访问过的点 seen.add(vertexStr) while(len(queue) &gt; 0): vertex = queue.pop(0) nodes = graph[vertex] for w in nodes: if w not in seen: queue.append(w) seen.add(w) print(vertex)BFS(graph, \"A\")","categories":[],"tags":[]},{"title":"深度优先遍历原理及其实现","slug":"深度优先遍历原理及其实现","date":"2019-07-02T14:27:49.000Z","updated":"2019-07-02T14:44:46.772Z","comments":true,"path":"2019/07/02/深度优先遍历原理及其实现/","link":"","permalink":"http://yoursite.com/2019/07/02/深度优先遍历原理及其实现/","excerpt":"","text":"DFS 实现原理及python代码原理​ DFS核心原理是使用栈对图的顶点进行遍历操作。 step1​ 建立Seen[] 数组，将已经访问的节点存入该集合。 ​ 开始节点入栈S，并存入Seen数组。 step2​ 开始循环判断栈是否为空。若不空，则弹出栈顶元素，将该元素所有的邻接点（判断是否在seen中后）压入栈中，并对应节点存入seen中，输出此轮弹出的节点。 python代码实现12345678910111213141516171819202122232425graph =&#123; \"A\" : [\"B\", \"C\"], \"B\" : [\"A\", \"C\", \"D\"], \"C\" : [\"A\", \"B\", \"D\", \"E\"], \"D\" : [\"B\", \"C\", \"E\", \"F\"], \"E\" : [\"C\", \"D\"], \"F\" : [\"D\"] &#125;def DFS(graph, vertexStr): stack = [] stack.append(vertexStr) seen = set() #存放已经访问过的点 seen.add(vertexStr) while(len(stack) &gt; 0): vertex = stack.pop() nodes = graph[vertex] for w in nodes: if w not in seen: stack.append(w) seen.add(w) print(vertex)DFS(graph, \"A\")","categories":[],"tags":[]},{"title":"Floyd 代码实现","slug":"Floyd-代码实现","date":"2019-07-02T14:13:38.000Z","updated":"2019-07-02T14:16:03.163Z","comments":true,"path":"2019/07/02/Floyd-代码实现/","link":"","permalink":"http://yoursite.com/2019/07/02/Floyd-代码实现/","excerpt":"","text":"Floyd 代码实现1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N ../* D 和 Path， D记录最短路径长度，初始化为邻接矩阵 ，path记录两顶点间最短路径上经过的中间顶点*/void floyd(graph G, int Path[][])&#123; for(i = 0; i &lt; N; i++)&#123; for( j = 0; j &lt; N; j++)&#123; D[i][j] = G[i][j]; Path[i][j] = -1; &#125; &#125; for(k = 0; k &lt; N; k++)&#123; //第k轮，将k节点插入i，j中间更新最短路 长度 for(i = 0; i &lt; N; i++)&#123; for(j = 0; j &lt; N; j++)&#123; if(D[i][k] + D[k][j] &lt; D[i][j])&#123; //主要判断条件 D[i][j] = D[i][k] + D[k][j]; Path[i][j] = k; &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"dijkstra","slug":"dijkstra","date":"2019-07-02T11:39:58.000Z","updated":"2019-07-02T13:14:33.650Z","comments":true,"path":"2019/07/02/dijkstra/","link":"","permalink":"http://yoursite.com/2019/07/02/dijkstra/","excerpt":"","text":"dijkstra算法的一般原理及实现​ 初始变量：VertexsNum //顶点个数 ​ Arc[VertexsNum] [VertexsNum] //图的存储结构 ​ S[VertexsNum] = {0}; //已考察顶点的标记，初始为0；若已考察，置1 ​ dist[VertexsNum] //到该顶点当前的最小距离,dist[] 的初始值dist[i] = arcs[0][i]； ​ path[VertexsNum] //表示到该顶点当前最短路径的前驱节点 1. 原理step 1:​ 将源点的S[]数组对应位置置1，dist[] 的初始值dist[i] = arcs[0][i]； step2:​ 从顶点集合V-S中选出Vj，该Vj满足dist[j] = Min{dist [i] | Vi ∈ V-S} ，将Vj并入S； step3：​ 修改从V0出发到集合V-S上其他顶点Vk可达的最短路径长度：如果dist[j] + arcs[j][k] &lt; dist[k]，则令dist[k] = dist[j] + arcs[j][k]； step4：​ 重复 2~3，共操作n - 1次，直到所有顶点都包含在S中。 c代码伪码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;math.h&gt;#define VERTEXS 5void find_Min()&#123; //对当前未检查序列权值进行排序&#125;void dijsktra(int *arc, int *dist, int *S, int *path)&#123; int i, k; //循环变量 for(i = 0; i &lt; VERTEXS - 1; i++)&#123; sort(dist); //sort dist=&gt;V-S int j = find_Min(); s[j] = 1; //将顶点j并入已检查序列中 for(k = 0; k &lt; VERTEXS - 1;k++)&#123; if(dist[j] + arcs[j][k] &lt; dist[k])&#123; dist[k] = dist[j] + arcs[j][k]; path[k] = j; &#125; &#125; &#125;&#125;int main()&#123; int arc[VERTEXS][VERTEXS] = &#123; &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;,... &#125;; int dist[VERTEXS] = &#123;&#125;; //到该顶点当前的最小距离,dist[] 的初始值dist[i] = arcs\\[0][i]； int path[VERTEXS] = &#123;&#125;; //当前最短路径的前驱 int S[VERTEXS] = &#123;0&#125;; return 0;&#125;","categories":[],"tags":[]},{"title":"typora简易手册","slug":"typora简易手册","date":"2019-07-01T14:58:05.000Z","updated":"2019-07-01T15:44:35.128Z","comments":true,"path":"2019/07/01/typora简易手册/","link":"","permalink":"http://yoursite.com/2019/07/01/typora简易手册/","excerpt":"","text":"区域元素1.分割线​ 输入 *** / —，换行键换行 1--- 2.段落​ 按换行键 3.标题​ 开头#的个数（谨记加上文字之间空格），标题有1~6个级别，#表示开始，按换行键结束 123# H1## H2###### H6 4.引注​ 开头 “&gt;” + 空格 + 文字 ，按换行键换行，双按换行跳出 1234&gt; wang&gt; zhe&gt; rong&gt; yao wangzherongyao 5.序列​ 开头 “ * / + / - ” + 空格 + 文字，可以创建无序序列，换行键换行，删除键+shift+tab跳出 123* wang+ zhe- rong wang zhe rong ​ 开头 “ 1. ” + 空格 + 文字，可以创建有序序列 121. wang2. zhe wang zhe 6.可选序列(创建选项)​ 开头 “ * / + / - ” + 空格 + [ ] + 空格 + 文字，换行键换行，删除键+shift+tab跳出 1234- [ ] a+ [ ] b* [ ] c- [x] completed a b c completed 7.代码块​ 开头 “ + 语言名，开启代码块，换行键换行，光标下移键跳出123```markdown​```markdown 1(like this) 8.数学块​ 开头 ” $$ “ + 换行键，产生输入区域，输入Tex/LaTex格式的数学公式 1$$ $$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\end{vmatrix}$$ 9.表格开头 “ | ” + 列名 + “ | ” + 列名 + “ | ” + 换行键，创建一个2*2表格 将鼠标放置其上，弹出编辑尺寸，个数，文字等 1| 1 | 2 | 1 2 10.脚注在需要添加脚注的文字后面 + [ + ^ + 序列 + ]，注释的产生可以鼠标放置其上单击自动产生，添加信息 或人工添加 + [ + ^ + 序列 + ] + : 12脚注产生的方法[^footnote].[^footnote]:这个就是*脚注* 脚注产生的方法^footnote. 特征元素1.链接","categories":[],"tags":[{"name":"typora建议手册，时时看","slug":"typora建议手册，时时看","permalink":"http://yoursite.com/tags/typora建议手册，时时看/"}]},{"title":"并查集（after watching the video of dengshen）","slug":"并查集（after-watching-the-video-of-dengshen）","date":"2019-07-01T14:53:58.000Z","updated":"2019-07-02T15:05:47.477Z","comments":true,"path":"2019/07/01/并查集（after-watching-the-video-of-dengshen）/","link":"","permalink":"http://yoursite.com/2019/07/01/并查集（after-watching-the-video-of-dengshen）/","excerpt":"","text":"并查集视频观后有感原理​ 采用双亲法存放图，核心数据结构是一个数组parents[vertexNum]，存放各个并查集中节点的双亲节点位置，若为根节点，则置为-1（初始均为-1，加入边时，需要合理规定谁为父节点）。 ​ 建立寻根函数find_root，当压入边时，需要检查边的两个节点所在并查集的根节点是否一样，若一样，则位于同一并查集中，证明该图中存在环。否则当判断节点均位于同一并查集时，则图中不存在环。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define VERTICES 6/* initialize array of vertex parent and array of vertex rank*/void initialize(int parents[], int rank[])&#123; int i; for(i = 0; i &lt; VERTICES; i++)&#123; parents[i] = -1; rank[i] = 0; &#125;&#125;/*find root of vertex of arc to verdict*/int find_x_root(int parents[], int x)&#123; int x_root = x; while(parents[x_root] != -1)&#123; x_root = parents[x_root]; &#125; return x_root;&#125;/* union vertex set, 1 success 0 failed*/int union_vertexSet(int x, int y, int parent[], int rank[])&#123; int x_root = find_x_root(parent, x); int y_root = find_x_root(parent, y); if( x_root != y_root)&#123; if(rank[y_root] &gt; rank[x_root])&#123; parent[x_root] = y_root; &#125;else if(rank[y_root] &lt; rank[x_root])&#123; parent[y_root] = x_root; &#125;else&#123; parent[x_root] = y_root; rank[y_root]++; &#125; return 1; &#125;else&#123; return 0; &#125;&#125;int main(void)&#123; int parents[VERTICES] = &#123;0&#125;; int rank[VERTICES] = &#123;0&#125;; int edges[6][2]=&#123; &#123;0, 1&#125;, &#123;1, 2&#125;, &#123;1, 3&#125;, &#123;2, 4&#125;,&#123;3, 4&#125;, &#123;2, 5&#125;, &#125;; initialize(parents, rank); int i; for(i = 0; i &lt; 5; i++)&#123; int x = edges[i][0]; int y = edges[i][1]; if(union_vertexSet(x, y, parents, rank) == 0)&#123; printf(\"Cycle detected!\\n\"); exit(0); &#125; &#125; printf(\"No cycles found.\\n\"); return 0;&#125;","categories":[],"tags":[]},{"title":"my review of Mr.s yang","slug":"my-review-of-Mr-s-yang","date":"2019-06-30T11:29:30.000Z","updated":"2019-06-30T11:44:46.553Z","comments":true,"path":"2019/06/30/my-review-of-Mr-s-yang/","link":"","permalink":"http://yoursite.com/2019/06/30/my-review-of-Mr-s-yang/","excerpt":"","text":"这是一个人对于另外一个人的主观评价PART 01​ 半年的室友 PART 02​ 待人真诚的朋友 PART 03​ 希望成为永远的兄弟（我兄他弟） PART04​ 太过腼腆，自己活得很累","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-29T22:50:25.441Z","updated":"2019-06-29T22:50:25.441Z","comments":true,"path":"2019/06/30/hello-world/","link":"","permalink":"http://yoursite.com/2019/06/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}